# db-plan.md

## 1. List of tables (columns, data types, constraints)

### 1.1. `users`

- `id` **uuid** PK, `DEFAULT gen_random_uuid()`, **NOT NULL**
- `email` **citext**, **UNIQUE**, **NOT NULL**
- `password_hash` **text**, **NOT NULL**
- `created_at` **timestamptz**, `DEFAULT now()`, **NOT NULL**
- `updated_at` **timestamptz**, `DEFAULT now()`, **NOT NULL**

---

### 1.2. `profiles` (1:1 with `users`, its own ID + FK to `users`)

- `id` **uuid** PK, `DEFAULT gen_random_uuid()`, **NOT NULL**
- `user_id` **uuid**, **UNIQUE**, **NOT NULL**, FK → `users(id)` `ON DELETE CASCADE`
- `travel_style` **text** NULL _(allowed values validated in the app)_
- `accommodation_type` **text** NULL
- `climate_region` **text** NULL
- `completed_at` **timestamptz** NULL
- `updated_at` **timestamptz**, NULL

> 1:1 relationship is enforced via **UNIQUE(user_id)**.

---

### 1.3. `notes`

- `id` **uuid** PK, `DEFAULT gen_random_uuid()`, **NOT NULL**
- `user_id` **uuid**, **NOT NULL**, FK → `users(id)` `ON DELETE CASCADE`
- `title` **text**, `CHECK (char_length(title) BETWEEN 1 AND 200)`, **NOT NULL**
- `location` **text**, `CHECK (char_length(location) BETWEEN 1 AND 255)`, **NOT NULL**
- `body_md` **text**, **NOT NULL** _(1k–10k characters enforced in the app; see notes)_
- `created_at` **timestamptz**, `DEFAULT now()`, **NOT NULL**
- `updated_at` **timestamptz**, `DEFAULT now()`, **NOT NULL**
- `deleted_at` **timestamptz** NULL _(soft delete)_

> Extra uniqueness (for composite FKs): `UNIQUE (id, user_id)`

---

### 1.4. `trip_requests`

- `id` **uuid** PK, `DEFAULT gen_random_uuid()`, **NOT NULL**
- `user_id` **uuid**, **NOT NULL**, FK → `users(id)` `ON DELETE CASCADE`
- `note_id` **uuid**, **NOT NULL**
- `days` **integer** **NOT NULL**,
- `travelers` **integer** **NOT NULL**,
- `start_date` **timestamptz**, `DEFAULT now()`, **NOT NULL**
- `created_at` **timestamptz**, `DEFAULT now()`, **NOT NULL**

> Co-ownership enforcement (tenant safety):  
> Composite FK `FOREIGN KEY (note_id, user_id) REFERENCES notes(id, user_id) ON DELETE RESTRICT`  
> Extra uniqueness (to enable composite FKs downstream): `UNIQUE (id, user_id)`

---

### 1.5. `plan_generations`

- `id` **uuid** PK, `DEFAULT gen_random_uuid()`, **NOT NULL**
- `user_id` **uuid**, **NOT NULL**, FK → `users(id)` `ON DELETE CASCADE`
- `trip_request_id` **uuid**, **NOT NULL**
- `title` **text** **NOT NULL**
- `status` **plan_generation_status** (`queued|running|succeeded|failed`), **NOT NULL**
- `created_at` **timestamptz**, `DEFAULT now()`, **NOT NULL**
- `started_at` **timestamptz** NULL
- `finished_at` **timestamptz** NULL
- `input_payload` **jsonb**, **NOT NULL** _(snapshot of inputs: preferences, note, parameters)_
- `output_raw` **text** NULL _(raw model/LLM response)_
- `error_message` **text** NULL

> Co-ownership enforcement:  
> Composite FK `FOREIGN KEY (trip_request_id, user_id) REFERENCES trip_requests(id, user_id) ON DELETE CASCADE`  
> Extra helper uniqueness: `UNIQUE (id, user_id)`

---

### 1.6. `plans`

- `id` **uuid** PK, `DEFAULT gen_random_uuid()`, **NOT NULL**
- `user_id` **uuid**, **NOT NULL**, FK → `users(id)` `ON DELETE CASCADE`
- `trip_request_id` **uuid**, **NOT NULL**
- `plan_generation_id` **uuid**, **NOT NULL**
- `title` **text** **NOT NULL**
- `structure_type` **plan_structure** (`daily|list`), **NOT NULL**
- `days_count` **integer** NULL, `CHECK (days_count IS NULL OR days_count > 0)`
- `content` **text** **NOT NULL** _(markdown text for UI displaying)_
- `status` **plan_status** (`notgenerated|generated|accepted|rejected`), `DEFAULT 'notgenerated'`, **NOT NULL**
- `decision_reason` **text** NULL
- `decision_at` **timestamptz** NULL
- `adjusted_by_user` **boolean**, `DEFAULT false`, **NOT NULL**
- `created_at` **timestamptz**, `DEFAULT now()`, **NOT NULL**
- `updated_at` **timestamptz**, `DEFAULT now()`, **NOT NULL**

> Co-ownership enforcement:  
> Composite FK `FOREIGN KEY (trip_request_id, user_id) REFERENCES trip_requests(id, user_id) ON DELETE CASCADE`  
> Composite FK `FOREIGN KEY (plan_generation_id, user_id) REFERENCES plan_generations(id, user_id) ON DELETE CASCADE`  
> At most one plan per generation: **UNIQUE (plan_generation_id)**

---

### 1.7. `telemetry_events`

- `id` **bigserial** PK, **NOT NULL**
- `user_id` **uuid**, **NOT NULL**, FK → `users(id)` `ON DELETE CASCADE`
- `event_type` **text**, **NOT NULL**, `CHECK (event_type IN (
  'profile_completed', 'plan_created', 'plan_accepted', 'plan_rejected',
  'generation_queued', 'generation_started', 'generation_succeeded', 'generation_failed'
))`
- `payload` **jsonb**, **NOT NULL** _(minimal PII; flexible event attributes)_
- `occurred_at` **timestamptz**, `DEFAULT now()`, **NOT NULL**
- `created_at` **timestamptz**, `DEFAULT now()`, **NOT NULL**

---

## 2. Relationships (cardinality)

- `users` 1 — 1 `profiles` _(enforced via UNIQUE on `profiles.user_id`)_
- `users` 1 — N `notes`
- `users` 1 — N `trip_requests`
- `notes` 1 — N `trip_requests` _(via `note_id`; same `user_id` enforced by composite FK)_
- `trip_requests` 1 — N `plan_generations`
- `trip_requests` 1 — N `plans`
- `plan_generations` 1 — N `plans` _(each successful generation produces at most one plan; see UNIQUE)_
- `users` 1 — N `telemetry_events`

> All child tables include `user_id` and (often composite) FKs enforcing co-ownership (tenant safety).

---

## 3. Indexes

**Global (listings / filters):**

- `users_email_uindex` → `users(email)` **UNIQUE**
- `profiles_user_uindex` → `profiles(user_id)` **UNIQUE**
- `notes_user_created_idx` → `notes(user_id, created_at DESC)`
- `notes_user_updated_idx` → `notes(user_id, updated_at DESC)`
- `notes_not_deleted_idx` → **PARTIAL** `notes(user_id, updated_at DESC)` `WHERE deleted_at IS NULL`
- `trip_requests_user_created_idx` → `trip_requests(user_id, created_at DESC)`
- `plan_generations_user_created_idx` → `plan_generations(user_id, created_at DESC)`
- `plan_generations_user_status_idx` → `plan_generations(user_id, status, created_at DESC)`
- `plans_user_created_idx` → `plans(user_id, created_at DESC)`
- `plans_user_status_idx` → `plans(user_id, status, created_at DESC)`
- `plans_generation_idx` → `plans(plan_generation_id)`
- `telemetry_user_occurred_idx` → `telemetry_events(user_id, occurred_at DESC)`
- `telemetry_type_occurred_idx` → `telemetry_events(event_type, occurred_at DESC)`
- `telemetry_payload_gin` → `telemetry_events USING gin (payload jsonb_path_ops)`

**Integrity / composite FKs (to enforce co-ownership):**

- `notes_id_user_uq` → `notes(id, user_id)` **UNIQUE**
- `trip_requests_id_user_uq` → `trip_requests(id, user_id)` **UNIQUE**
- `plan_generations_id_user_uq` → `plan_generations(id, user_id)` **UNIQUE**

**Constraints:**

- Exactly one **accepted** plan per request: **PARTIAL UNIQUE** index on `plans(trip_request_id)` `WHERE status = 'accepted'`
- At most one plan per generation: **UNIQUE (plan_generation_id)**

---

## 4. PostgreSQL rules (types, extensions, policies)

**Extensions (required):**

```sql
CREATE EXTENSION IF NOT EXISTS citext;
CREATE EXTENSION IF NOT EXISTS pgcrypto; -- for gen_random_uuid()
```

**ENUM types used in the schema:**

```sql
CREATE TYPE plan_generation_status AS ENUM ('queued','running','succeeded','failed');
CREATE TYPE plan_status            AS ENUM ('notgenerated', 'generated','accepted','rejected');
CREATE TYPE plan_structure         AS ENUM ('daily','list');
```

**Conventions & policies:**

- All timestamps stored as **UTC** in **timestamptz** columns.
- **No RLS** in the MVP; ownership is enforced via `user_id` + (composite) FKs and backend logic.
- **Soft delete** on `notes` via `deleted_at`; listings use `WHERE deleted_at IS NULL`.
- `updated_at` maintained by the backend (no DB triggers in MVP).
- **Cascade delete behavior:**
  - When a **user** is deleted: all related plans, plan_generations, trip_requests, notes, profiles, and telemetry are deleted (`ON DELETE CASCADE`)
  - When a **trip_request** is deleted: all related plans and plan_generations are deleted (`ON DELETE CASCADE`)
  - When a **plan_generation** is deleted: all related plans are deleted (`ON DELETE CASCADE`), but trip_request remains
  - When a **note** is deleted: trip_requests are protected (`ON DELETE RESTRICT`) to preserve data integrity
- Telemetry: raw events; consider **monthly partitioning by `occurred_at`** as volume grows.

---

## 5. Additional notes / design decisions

- **Regeneration flow (no self-reference on generations):**  
  A non-accepted plan can trigger a new `plan_generations` row (usually with the same `trip_request_id`).  
  The resulting plan points to that run via `plans.plan_generation_id`. Historical lineage can be inferred by sorting by timestamps and matching `trip_request_id`.
- **Canonical plan content as JSONB** (`plans.content`) satisfies PRD (“structured JSON document”). `content_md` is optional for rendering/editing (can be derived from JSON in the app).
- **`body_md` length (1k–10k chars)** is required by PRD but, per MVP decisions, enforced in the application. If needed, add:  
  `CHECK (char_length(body_md) BETWEEN 100 AND 10000)`.
- **Stateless sessions (JWT)**: no session/auth tables.
- **Upper sanity limits** for `days` and `travelers` are not enforced in DB (easier to tune in the app); can add later, e.g., `days <= 60`, `travelers <= 20`.
- **Minimal PII in telemetry**; fast aggregations via `(user_id, occurred_at)` and `(event_type, occurred_at)`; GIN on `payload` for ad-hoc queries.
- **Cross-tenant safety**: composite FKs (`(child_fk_id, user_id) → (parent.id, parent.user_id)`) **enforce** co-ownership at the DB layer, reducing backend mistakes.
